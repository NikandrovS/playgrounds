<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Обозреватель потока событий Slack-бота</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;500;600;700&family=Outfit:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">
<style>
*,*::before,*::after{box-sizing:border-box;margin:0;padding:0}
:root{
  --bg:#0a0c10;--sidebar:#0d1017;--card:#12151e;--card-glass:rgba(18,21,30,.7);
  --border:#1e2230;--border-bright:#2a3042;
  --text:#d4d7e0;--text-muted:#7a7f94;--text-dim:#484d60;
  --accent:#7c83ff;--accent-hover:#9ba0ff;--accent-glow:rgba(124,131,255,.15);
  --filter:#3b4252;--check:#92400e;--service:#065f46;
  --db:#1e3a5f;--slack:#4c1d95;
  --branch:#c2410c;--early-exit:#7f1d1d;
  --filter-text:#a8b0c0;--filter-accent:#64748b;
  --check-text:#fbbf24;--check-accent:#d97706;
  --service-text:#34d399;--service-accent:#059669;
  --db-text:#60a5fa;--db-accent:#2563eb;
  --slack-text:#a78bfa;--slack-accent:#7c3aed;
  --queue-text:#fcd34d;--queue-accent:#ca8a04;
  --branch-text:#fdba74;--branch-accent:#ea580c;
  --early-exit-text:#fca5a5;--early-exit-accent:#ef4444;
  --connector:#1e2230;
}
html{font-family:'Outfit',sans-serif;font-size:14px;color:var(--text);background:var(--bg);overflow:hidden;height:100%}
body{display:flex;height:100vh;overflow:hidden;background:
  radial-gradient(circle at 20% 50%,rgba(124,131,255,.03) 0%,transparent 50%),
  radial-gradient(circle at 80% 20%,rgba(99,102,241,.02) 0%,transparent 40%),
  var(--bg)}

/* DOT GRID OVERLAY */
body::before{content:'';position:исправлено;inset:0;z-index:0;pointer-events:none;
  background-image:radial-gradient(circle,rgba(124,131,255,.06) 1px,transparent 1px);
  background-size:24px 24px}

/* SIDEBAR */
.sidebar{width:272px;min-width:272px;background:var(--sidebar);border-right:1px solid var(--border);
  display:flex;flex-direction:column;overflow:hidden;z-index:10;position:relative;
  backdrop-filter:blur(12px)}
.sidebar-header{padding:20px 18px 16px;border-bottom:1px solid var(--border)}
.sidebar-header h1{font-family:'IBM Plex Mono',monospace;font-size:13px;font-weight:600;
  letter-spacing:0.5px;text-transform:uppercase;color:var(--accent);margin-bottom:14px;
  display:flex;align-items:center;gap:8px}
.sidebar-header h1::before{content:'';display:inline-block;width:8px;height:8px;
  background:var(--accent);border-radius:2px;box-shadow:0 0 8px var(--accent-glow),0 0 16px rgba(124,131,255,.1)}
.search-input{width:100%;padding:9px 12px;background:rgba(255,255,255,.03);
  border:1px solid var(--border);border-radius:8px;color:var(--text);font-size:13px;
  font-family:'Outfit',sans-serif;outline:none;transition:all .2s}
.search-input:focus{border-color:var(--accent);background:rgba(124,131,255,.04);
  box-shadow:0 0 0 3px rgba(124,131,255,.08)}
.search-input::placeholder{color:var(--text-dim);font-weight:300}
.event-list{flex:1;overflow-y:auto;padding:8px 8px}
.event-list::-webkit-scrollbar{width:4px}
.event-list::-webkit-scrollbar-track{background:transparent}
.event-list::-webkit-scrollbar-thumb{background:var(--border);border-radius:2px}
.event-list::-webkit-scrollbar-thumb:hover{background:var(--border-bright)}
.category-label{font-family:'IBM Plex Mono',monospace;font-size:10px;font-weight:600;
  text-transform:uppercase;letter-spacing:1.5px;color:var(--text-dim);
  padding:14px 10px 6px;user-select:none}
.event-item{padding:8px 10px;border-radius:8px;cursor:pointer;font-size:13px;font-weight:400;
  color:var(--text-muted);transition:all .15s ease;display:flex;align-items:center;gap:8px;
  user-select:none;position:relative;margin-bottom:1px}
.event-item:hover{background:rgba(124,131,255,.06);color:var(--text)}
.event-item.active{background:rgba(124,131,255,.1);color:#fff;font-weight:500}
.event-item.active::before{content:'';position:absolute;left:0;top:6px;bottom:6px;width:3px;
  background:var(--accent);border-radius:0 2px 2px 0;box-shadow:0 0 6px var(--accent-glow)}
.event-item.active .event-dot{background:var(--accent);box-shadow:0 0 6px var(--accent-glow)}
.event-item.hidden{display:none}
.event-dot{width:6px;height:6px;border-radius:50%;background:var(--text-dim);flex-shrink:0;
  transition:all .15s}
.event-name{white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
.mode-toggle{padding:14px 18px;border-top:1px solid var(--border);background:rgba(0,0,0,.15)}
.mode-toggle label{display:flex;align-items:center;gap:10px;font-size:12px;
  color:var(--text-muted);cursor:pointer;user-select:none}
.mode-toggle input{display:none}
.toggle-track{width:36px;height:20px;border-radius:10px;background:var(--border);position:relative;
  transition:all .25s;flex-shrink:0}
.toggle-track::after{content:'';position:absolute;top:3px;left:3px;width:14px;height:14px;
  border-radius:50%;background:var(--text-dim);transition:all .25s cubic-bezier(.4,.0,.2,1)}
.mode-toggle input:checked+.toggle-track{background:var(--accent);box-shadow:0 0 10px var(--accent-glow)}
.mode-toggle input:checked+.toggle-track::after{left:19px;background:#fff}
.mode-toggle input:disabled+.toggle-track{opacity:.25;cursor:not-allowed}
.mode-toggle input:disabled~.mode-label{opacity:.25;cursor:not-allowed}
.mode-label{font-weight:500;font-family:'IBM Plex Mono',monospace;font-size:11px;
  letter-spacing:.3px}

/* MAIN */
.main{flex:1;display:flex;flex-direction:column;overflow:hidden;min-width:0;position:relative;z-index:1}

/* LEGEND */
.legend{display:flex;gap:6px;padding:12px 24px;border-bottom:1px solid var(--border);
  flex-wrap:wrap;align-items:center;background:rgba(13,16,23,.6);backdrop-filter:blur(8px)}
.legend-chip{padding:4px 12px;border-radius:6px;font-size:11px;font-weight:600;cursor:pointer;
  transition:all .2s;border:1px solid transparent;user-select:none;
  font-family:'IBM Plex Mono',monospace;letter-spacing:.3px;position:relative}
.legend-chip:hover{transform:translateY(-1px)}
.legend-chip.active{box-shadow:0 0 0 2px var(--accent),0 0 12px var(--accent-glow)}
.legend-chip.filter{background:rgba(59,66,82,.5);color:var(--filter-text);border-color:var(--filter-accent)}
.legend-chip.check{background:rgba(146,64,14,.4);color:var(--check-text);border-color:var(--check-accent)}
.legend-chip.service{background:rgba(6,95,70,.4);color:var(--service-text);border-color:var(--service-accent)}
.legend-chip.db{background:rgba(30,58,95,.4);color:var(--db-text);border-color:var(--db-accent)}
.legend-chip.slack{background:rgba(76,29,149,.4);color:var(--slack-text);border-color:var(--slack-accent)}
.legend-chip.queue{background:rgba(66,32,6,.5);color:var(--queue-text);border-color:var(--queue-accent)}
.legend-chip.branch{background:rgba(194,65,12,.2);border:1px solid var(--branch-accent);color:var(--branch-text)}
.legend-chip.early-exit{background:rgba(127,29,29,.4);color:var(--early-exit-text);border:1px dashed var(--early-exit-accent)}

/* FLOW AREA */
.flow-area{flex:1;overflow-y:auto;padding:28px 36px 40px;position:relative}
.flow-area::-webkit-scrollbar{width:5px}
.flow-area::-webkit-scrollbar-track{background:transparent}
.flow-area::-webkit-scrollbar-thumb{background:var(--border);border-radius:3px}
.flow-area::-webkit-scrollbar-thumb:hover{background:var(--border-bright)}
.flow-title{font-size:22px;font-weight:700;margin-bottom:4px;letter-spacing:-.3px;
  background:linear-gradient(135deg,#fff 0%,var(--text) 100%);-webkit-background-clip:text;
  -webkit-text-fill-color:transparent;background-clip:text}
.flow-source{font-size:12px;color:var(--text-dim);margin-bottom:24px;
  font-family:'IBM Plex Mono',monospace;padding:4px 0;
  border-bottom:1px solid var(--border);display:inline-block}
.flow-container{display:flex;flex-direction:column;align-items:flex-start;gap:0;padding-bottom:40px}

/* STEP ANIMATIONS */
.step-wrapper{display:flex;flex-direction:column;align-items:flex-start;opacity:0;
  transform:translateY(8px) scale(.98);
  transition:opacity .3s cubic-bezier(.4,.0,.2,1),transform .3s cubic-bezier(.4,.0,.2,1)}
.step-wrapper.visible{opacity:1;transform:translateY(0) scale(1)}

/* STEP CARDS - Glass morphism with left accent strip */
.step-card{padding:10px 14px 10px 16px;border-radius:8px;font-size:13px;line-height:1.5;
  max-width:540px;position:relative;border:1px solid rgba(255,255,255,.04);
  backdrop-filter:blur(4px);transition:transform .15s,box-shadow .15s;
  border-left:3px solid transparent}
.step-card:hover{transform:translateX(2px);box-shadow:0 4px 20px rgba(0,0,0,.3)}
.step-card.filter{background:rgba(59,66,82,.25);color:var(--filter-text);
  border-left-color:var(--filter-accent)}
.step-card.check{background:rgba(146,64,14,.2);color:var(--check-text);
  border-left-color:var(--check-accent)}
.step-card.service{background:rgba(6,95,70,.2);color:var(--service-text);
  border-left-color:var(--service-accent)}
.step-card.db{background:rgba(30,58,95,.25);color:var(--db-text);
  border-left-color:var(--db-accent)}
.step-card.slack{background:rgba(76,29,149,.2);color:var(--slack-text);
  border-left-color:var(--slack-accent)}
.step-card.queue{background:rgba(66,32,6,.3);color:var(--queue-text);
  border-left-color:var(--queue-accent)}
.step-card.branch{background:rgba(194,65,12,.12);border:2px dashed var(--branch-accent);
  border-left:3px solid var(--branch-accent);color:var(--branch-text);
  border-radius:8px;padding:12px 20px;text-align:center}
.step-card.branch .step-label{color:var(--branch-text)}
.step-card.early-exit{background:rgba(127,29,29,.2);color:var(--early-exit-text);
  border:1px dashed rgba(239,68,68,.4);border-left:3px solid var(--early-exit-accent);opacity:.85}
.step-card.early-exit .exit-footer{font-size:9px;font-weight:700;text-transform:uppercase;
  letter-spacing:1.2px;margin-top:4px;color:#f87171;font-family:'IBM Plex Mono',monospace}
.step-label{font-family:'IBM Plex Mono',monospace;font-size:10px;font-weight:600;
  text-transform:uppercase;letter-spacing:1px;margin-bottom:3px;opacity:.65}
.step-text{font-weight:400;line-height:1.55}

/* CONNECTORS */
.arrow-connector{width:2px;height:18px;margin-left:24px;position:relative;
  background:linear-gradient(180deg,var(--connector) 0%,rgba(124,131,255,.15) 100%)}
.arrow-connector::after{content:'';position:absolute;bottom:-1px;left:-2px;
  border-left:3px solid transparent;border-right:3px solid transparent;
  border-top:4px solid rgba(124,131,255,.25)}
.arrow-connector.branch-yes{margin-left:40px}
.arrow-connector.branch-no{margin-left:40px}

/* BRANCH */
.branch-block{display:flex;flex-direction:column;align-items:flex-start;width:100%}
.branch-label{font-family:'IBM Plex Mono',monospace;font-size:11px;font-weight:700;
  color:var(--branch-text);margin-left:24px;margin-bottom:2px;text-transform:uppercase;
  letter-spacing:.5px}
.branch-paths{display:flex;gap:28px;width:100%;margin-top:6px}
.branch-path{display:flex;flex-direction:column;align-items:flex-start;gap:0;flex:1;
  max-width:540px;min-width:180px;
  border-left:2px solid var(--border);padding-left:14px;padding-bottom:8px;margin-top:4px;
  position:relative;transition:border-color .2s}
.branch-path:hover{border-left-color:var(--border-bright)}
.branch-path-label{font-family:'IBM Plex Mono',monospace;font-size:11px;font-weight:700;
  padding:3px 10px;border-radius:4px;margin-bottom:6px;user-select:none;letter-spacing:.3px}
.branch-path-label.yes{color:#34d399;background:rgba(52,211,153,.1);border:1px solid rgba(52,211,153,.2)}
.branch-path-label.no{color:#f87171;background:rgba(248,113,113,.1);border:1px solid rgba(248,113,113,.2)}

/* HIGHLIGHT FILTERING */
.highlight-filter .step-card:not(.filter),
.highlight-check .step-card:not(.check),
.highlight-service .step-card:not(.service),
.highlight-db .step-card:not(.db),
.highlight-slack .step-card:not(.slack),
.highlight-queue .step-card:not(.queue),
.highlight-branch .step-card:not(.branch),
.highlight-early-exit .step-card:not(.early-exit){opacity:.15;filter:grayscale(.5)}

/* EMPTY STATE */
.empty-state{display:flex;flex-direction:column;align-items:center;justify-content:center;
  height:100%;color:var(--text-dim);gap:12px}
.empty-state-icon{font-size:48px;opacity:.2;animation:pulse 3s ease-in-out infinite}
.empty-state div:nth-child(2){font-weight:500;font-size:15px;color:var(--text-muted)}
.empty-state div:nth-child(3){font-family:'IBM Plex Mono',monospace}
@keyframes pulse{0%,100%{opacity:.2;transform:scale(1)}50%{opacity:.35;transform:scale(1.05)}}

/* BOTTOM BAR */
.bottom-bar{border-top:1px solid var(--border);padding:14px 24px;display:flex;
  align-items:center;gap:14px;background:var(--sidebar);min-height:60px;
  backdrop-filter:blur(12px)}
.prompt-text{flex:1;font-size:14px;color:var(--text);line-height:1.55;
  white-space:nowrap;overflow:hidden;text-overflow:ellipsis;font-weight:400}
.copy-btn{padding:7px 16px;border-radius:6px;background:var(--accent);color:#fff;
  font-size:12px;font-weight:600;border:none;cursor:pointer;white-space:nowrap;
  transition:all .2s;font-family:'IBM Plex Mono',monospace;letter-spacing:.3px}
.copy-btn:hover{background:var(--accent-hover);box-shadow:0 2px 12px var(--accent-glow);
  transform:translateY(-1px)}
.copy-btn:active{transform:translateY(0)}
.copy-btn.copied{background:#059669;box-shadow:0 2px 12px rgba(5,150,105,.2)}

/* RESPONSIVE */
@media(max-width:700px){
  .sidebar{position:исправлено;left:-272px;top:0;bottom:0;transition:left .3s cubic-bezier(.4,.0,.2,1);
    z-index:100}
  .sidebar.open{left:0;box-shadow:16px 0 48px rgba(0,0,0,.5)}
  .menu-toggle{display:flex !important}
  .flow-area{padding:52px 16px 16px}
  .branch-paths{flex-direction:column;gap:16px}
  .branch-path{min-width:unset;max-width:100%}
  .flow-title{font-size:18px}
  .legend{padding:10px 16px;gap:4px}
  .legend-chip{font-size:10px;padding:3px 8px}
}
.menu-toggle{display:none;position:исправлено;top:12px;left:12px;z-index:101;
  width:38px;height:38px;border-radius:10px;background:var(--card);border:1px solid var(--border);
  color:var(--text);font-size:18px;cursor:pointer;align-items:center;justify-content:center;
  transition:all .2s;backdrop-filter:blur(8px)}
.menu-toggle:hover{background:var(--border);border-color:var(--accent)}

/* OVERLAY for mobile sidebar */
.sidebar-overlay{display:none;position:исправлено;inset:0;background:rgba(0,0,0,.5);z-index:99;
  backdrop-filter:blur(2px)}
.sidebar-overlay.visible{display:block}

/* STEP CARD NUMBER BADGE */
.step-number{position:absolute;right:10px;top:8px;font-family:'IBM Plex Mono',monospace;
  font-size:9px;font-weight:600;color:rgba(255,255,255,.12);letter-spacing:.5px}
</style>
</head>
<body>
<button class="menu-toggle" id="menuToggle" aria-label="Toggle sidebar">&#9776;</button>
<div class="sidebar-overlay" id="sidebarOverlay"></div>
<aside class="sidebar" id="sidebar" role="navigation">
  <div class="sidebar-header">
    <h1>Обозреватель потока событий</h1>
    <input type="text" class="search-input" id="searchInput" placeholder="Поиск событий..." aria-label="Поиск событий">
  </div>
  <div class="event-list" id="eventList" role="listbox" tabindex="0" aria-label="Event list"></div>
  <div class="mode-toggle">
    <label>
      <input type="checkbox" id="modeToggle" disabled>
      <span class="toggle-track"></span>
      <span class="mode-label">Режим гейткипера</span>
    </label>
  </div>
</aside>
<main class="main">
  <div class="legend" id="legend" role="toolbar" aria-label="Step type legend"></div>
  <div class="flow-area" id="flowArea">
    <div class="empty-state" id="emptyState">
      <div class="empty-state-icon">&#8644;</div>
      <div>Выберите событие, чтобы посмотреть его поток</div>
      <div style="font-size:11px">Используйте стрелки для навигации, Enter для выбора</div>
    </div>
  </div>
  <div class="bottom-bar">
    <div class="prompt-text" id="promptText">Выберите событие, чтобы увидеть описание его потока</div>
    <button class="copy-btn" id="copyBtn">Копировать</button>
  </div>
</main>
<script>
(function(){
"use strict";

/* ========== STEP TYPE DEFINITIONS ========== */
const STEP_TYPES = [
  {key:'filter',label:'Фильтр',bg:'var(--filter)',color:'var(--filter-text)'},
  {key:'check',label:'Проверка',bg:'var(--check)',color:'var(--check-text)'},
  {key:'service',label:'Сервис',bg:'var(--service)',color:'var(--service-text)'},
  {key:'db',label:'База данных',bg:'var(--db)',color:'var(--db-text)'},
  {key:'slack',label:'Slack API',bg:'var(--slack)',color:'var(--slack-text)'},
  {key:'queue',label:'BullMQ',bg:'#422006',color:'var(--queue-text)',border:'1px solid var(--queue-accent)'},
  {key:'branch',label:'Ветвление',bg:'rgba(194,65,12,.15)',color:'var(--branch-text)',border:'1px solid var(--branch-accent)'},
  {key:'early-exit',label:'Ранний выход',bg:'var(--early-exit)',color:'var(--early-exit-text)',border:'1px dashed #ef4444'},
];

const TYPE_LABELS = STEP_TYPES.reduce(function(acc, t){acc[t.key]=t.label;return acc;}, {});
function getTypeLabel(type){return TYPE_LABELS[type] || type.replace('-',' ');}


/* ========== EVENT FLOW DATA ========== */
function S(type,text){return{type:type,text:text}}
function B(text,yes,no){return{type:'branch',text:text,yes:yes,no:no}}

const EVENTS = [
  /* ===== MESSAGES ===== */
  {
    id:'new-message',category:'Сообщения',name:'Новое сообщение',
    source:'src/slack/handlers/event.handlers.ts:handleMessage',
    hasModeVariant:true,
    prompt:'Когда пользователь пишет сообщение в настроенном канале, бот проверяет совпадение с regex-шаблоном ревью. Если есть совпадение, он создаёт задачу на ревью и назначает ревьюеров из волны 1 (или гейткипера в соответствующем режиме), затем отвечает в треде, упоминая их, и обновляет счётчик эмодзи.',
    steps:[
      S('filter','Отфильтровать сообщения ботов и подтипы сообщений (правки, удаления)'),
      S('filter','Проверить наличие полей user и text'),
      S('check','Найти конфигурацию канала'),
      S('early-exit','Канал не найден или неактивен → остановка'),
      S('check','Проверить regex на безопасность (ReDoS)'),
      S('early-exit','Regex небезопасен → остановка'),
      S('check','Проверить текст сообщения по regex канала'),
      S('early-exit','Нет совпадения с regex → остановка'),
      S('service','Получить участников волны 1 с учётом лимита max_reviewers'),
      S('service','Исключить автора, перемешать, применить лимит max_reviewers'),
      S('early-exit','0 подходящих ревьюеров → остановка'),
      S('db','createTaskWithReviewers — INSERT задачи и ревьюеров в одной транзакции'),
      S('slack','Ответить в треде с упоминанием назначенных ревьюеров'),
      S('slack','Посчитать оставшихся и обновить эмодзи счётчика на исходном сообщении'),
    ],
    gatekeeperSteps:[
      S('filter','Отфильтровать сообщения ботов и подтипы сообщений (правки, удаления)'),
      S('filter','Проверить наличие полей user и text'),
      S('check','Найти конфигурацию канала'),
      S('early-exit','Канал не найден или неактивен → остановка'),
      S('check','Проверить regex на безопасность (ReDoS)'),
      S('early-exit','Regex небезопасен → остановка'),
      S('check','Проверить текст сообщения по regex канала'),
      S('early-exit','Нет совпадения с regex → остановка'),
      S('service','Режим гейткипера: назначить только gatekeeper_slack_id (без поиска волн)'),
      S('db','createTaskWithReviewers — INSERT задачи и гейткипера в транзакции'),
      S('slack','Ответить в треде с упоминанием гейткипера'),
      S('slack','Обновить эмодзи счётчика ревьюеров'),
    ],
  },
  {
    id:'approve',category:'Сообщения',name:'++ (одобрение)',
    source:'src/slack/handlers/event.handlers.ts:handleThreadCommand(approve)',
    hasModeVariant:true,
    prompt:'Когда ревьюер пишет ++ в треде, его одобрение фиксируется. Если все ревьюеры текущей волны завершены, бот пытается перейти к следующей волне или завершает задачу. В режиме гейткипера одобрение гейткипера сразу завершает задачу.',
    steps:[
      S('check','Получить активную задачу в треде'),
      S('early-exit','Нет активной задачи → тихий выход'),
      S('check','Статус задачи должен быть "in_review"'),
      S('early-exit','Неверный статус → тихий выход'),
      S('check','Проверить, что пользователь — ревьюер текущей волны'),
      S('early-exit','Не ревьюер → тихий выход'),
      S('db','approveReview — SELECT FOR UPDATE, установить reviewer = "approved"'),
      S('check','Проверить, что все ревьюеры волны завершены (approved/skipped)'),
      B('Все завершены?',
        [
          S('service','Найти следующую подходящую волну (обычный поток)'),
          B('Следующая волна существует?',
            [
              S('db','INSERT ревьюеров следующей волны, UPDATE tasks.current_wave'),
              S('slack','Уведомить ревьюеров новой волны в треде'),
              S('slack','Обновить эмодзи счётчика ревьюеров'),
            ],
            [
              S('db','UPDATE статус задачи на "completed"'),
              S('slack','Опубликовать сообщение о завершении в треде'),
              S('slack','Добавить реакцию с галочкой'),
              S('slack','Удалить эмодзи счётчика ревьюеров'),
            ]
          ),
        ],
        [
          S('slack','Обновить эмодзи счётчика ревьюеров'),
        ]
      ),
    ],
    gatekeeperSteps:[
      S('check','Получить активную задачу в треде'),
      S('early-exit','Нет активной задачи → тихий выход'),
      S('check','Статус задачи должен быть "in_review"'),
      S('early-exit','Неверный статус → тихий выход'),
      S('check','Проверить, что пользователь — ревьюер текущей волны'),
      S('early-exit','Не ревьюер → тихий выход'),
      S('db','approveReview — SELECT FOR UPDATE, установить reviewer = "approved"'),
      S('check','Проверить, что все ревьюеры волны завершены'),
      B('Все завершены? (gatekeeper path)',
        [
          S('check','Проверить, одобрил ли гейткипер'),
          B('Гейткипер одобрил?',
            [
              S('db','UPDATE задачи на "completed" — одобрение гейткипера завершает задачу'),
              S('slack','Опубликовать сообщение о завершении'),
              S('slack','Добавить реакцию с галочкой'),
            ],
            [
              S('db','INSERT гейткипера в волну N+1, UPDATE tasks.current_wave'),
              S('slack','Уведомить гейткипера в треде'),
              S('slack','Обновить эмодзи счётчика ревьюеров'),
            ]
          ),
        ],
        [
          S('slack','Обновить эмодзи счётчика ревьюеров'),
        ]
      ),
    ],
  },
  {
    id:'rework',category:'Сообщения',name:'-- (на доработку)',
    source:'src/slack/handlers/event.handlers.ts:handleThreadCommand(rework)',
    hasModeVariant:false,
    prompt:'Когда ревьюер пишет -- в треде, задача отправляется на доработку. Автор должен исправить проблемы и написать "исправлено", чтобы возобновить ревью.',
    steps:[
      S('check','Получить активную задачу в треде'),
      S('early-exit','Нет активной задачи → тихий выход'),
      S('check','Статус задачи должен быть "in_review"'),
      S('early-exit','Неверный статус → тихий выход'),
      S('check','Проверить, что пользователь — ревьюер текущей волны'),
      S('early-exit','Не ревьюер → тихий выход'),
      S('db','sendToRework — UPDATE статуса задачи на "rework"'),
      S('slack','Ответить в треде: "отправлено на доработку пользователем @user"'),
    ],
  },
  {
    id:'исправлено',category:'Сообщения',name:'исправлено',
    source:'src/slack/handlers/event.handlers.ts:handleThreadCommand(исправлено)',
    hasModeVariant:false,
    prompt:'Когда автор задачи пишет "исправлено" в треде доработки, задача возвращается в статус in_review. Просроченные отложенные ревьюеры сбрасываются в pending, а все ожидающие ревьюеры получают повторное уведомление.',
    steps:[
      S('check','Получить активную задачу в треде'),
      S('early-exit','Нет активной задачи → тихий выход'),
      S('check','Статус задачи должен быть "rework"'),
      S('early-exit','Не в rework → тихий выход'),
      S('check','Проверить, что отправитель — автор задачи'),
      S('early-exit','Не автор → тихий выход'),
      S('db','markFixed — UPDATE статуса задачи на "in_review"'),
      S('service','Получить ожидающих ревьюеров (сбрасывает просроченных отложенных в pending)'),
      S('slack','Уведомить ожидающих ревьюеров: "пожалуйста, пересмотрите"'),
    ],
  },
  {
    id:'skip',category:'Сообщения',name:'!skip @user',
    source:'src/slack/handlers/event.handlers.ts:handleSkipMessage',
    hasModeVariant:true,
    prompt:'Когда кто-то пишет !skip @user в треде, целевой ревьюер помечается как skipped. Если все ревьюеры волны завершены, бот переходит к следующей волне или завершает задачу. В режиме гейткипера переходы волн используют виртуальные волны гейткипера.',
    steps:[
      S('check','Получить активную задачу в треде'),
      S('early-exit','Нет активной задачи → сообщение об ошибке'),
      S('db','skipReviewer — SELECT FOR UPDATE, установить reviewer = "skipped"'),
      S('slack','Ответить в треде: "ревьюер пропущен пользователем @sender"'),
      S('check','Проверить, что все ревьюеры волны завершены'),
      B('Задача завершена?',
        [
          S('slack','Опубликовать сообщение о завершении'),
          S('slack','Добавить реакцию с галочкой'),
          S('slack','Удалить эмодзи счётчика ревьюеров'),
        ],
        [
          S('slack','Обновить эмодзи счётчика ревьюеров'),
          S('check','Проверить, была ли смена волны'),
          B('Волна сменилась?',
            [
              S('service','Получить ожидающих ревьюеров новой волны'),
              S('slack','Уведомить ревьюеров новой волны в треде'),
            ],
            []
          ),
        ]
      ),
    ],
    gatekeeperSteps:[
      S('check','Получить активную задачу в треде'),
      S('early-exit','Нет активной задачи → сообщение об ошибке'),
      S('db','skipReviewer — SELECT FOR UPDATE (переход волны гейткипера внутри)'),
      S('slack','Ответить в треде: "ревьюер пропущен пользователем @sender"'),
      S('check','Проверить, что все ревьюеры волны завершены'),
      B('Задача завершена? (гейткипер проверяет своё одобрение)',
        [
          S('slack','Опубликовать сообщение о завершении'),
          S('slack','Добавить реакцию с галочкой'),
          S('slack','Удалить эмодзи счётчика ревьюеров'),
        ],
        [
          S('slack','Обновить эмодзи счётчика ревьюеров'),
          S('check','Гейткипер не одобрил → INSERT гейткипера в волну N+1'),
          S('slack','Уведомить гейткипера в треде'),
        ]
      ),
    ],
  },
  {
    id:'pass',category:'Сообщения',name:'!pass @user',
    source:'src/slack/handlers/event.handlers.ts:handlePassMessage',
    hasModeVariant:false,
    prompt:'Когда ревьюер пишет !pass @user в треде, его ревью передаётся целевому пользователю. Отправитель помечается как skipped, а цель добавляется как новый ожидающий ревьюер.',
    steps:[
      S('check','Получить активную задачу в треде'),
      S('early-exit','Нет активной задачи → сообщение об ошибке'),
      S('db','passReview — SELECT FOR UPDATE задачи'),
      S('check','Проверить, что отправитель — pending/postponed ревьюер'),
      S('early-exit','Не активный ревьюер → ошибка'),
      S('check','Проверить, что цель не уже в pending'),
      S('early-exit','Цель уже в pending → ошибка'),
      S('db','INSERT нового ревьюера (цель, pending) + UPDATE отправителя в "skipped"'),
      S('slack','Ответить в треде: "ревью передано от @sender к @target"'),
      S('slack','Обновить эмодзи счётчика ревьюеров'),
    ],
  },
  {
    id:'stop',category:'Сообщения',name:'!stop',
    source:'src/slack/handlers/event.handlers.ts:handleStopMessage',
    hasModeVariant:true,
    prompt:'Когда в треде пишут !stop, задача принудительно завершается. В обычном режиме остановить задачу может только автор. В режиме гейткипера это также может гейткипер.',
    steps:[
      S('check','Получить активную задачу в треде'),
      S('early-exit','Нет активной задачи → сообщение об ошибке'),
      S('check','Проверить, что отправитель — автор задачи'),
      S('early-exit','Не автор → ошибка "только автор может остановить"'),
      S('db','completeTask — UPDATE статуса на "completed"'),
      S('slack','Ответить в треде: "задача остановлена и завершена"'),
      S('slack','Добавить реакцию с галочкой'),
      S('slack','Удалить эмодзи счётчика ревьюеров'),
    ],
    gatekeeperSteps:[
      S('check','Получить активную задачу в треде'),
      S('early-exit','Нет активной задачи → сообщение об ошибке'),
      S('check','Проверить, что отправитель — автор ИЛИ гейткипер'),
      S('early-exit','Ни автор, ни гейткипер → ошибка'),
      S('db','completeTask — UPDATE статуса на "completed"'),
      S('slack','Ответить в треде: "задача остановлена и завершена"'),
      S('slack','Добавить реакцию с галочкой'),
      S('slack','Удалить эмодзи счётчика ревьюеров'),
    ],
  },
  {
    id:'review-cmd',category:'Сообщения',name:'!review',
    source:'src/slack/handlers/event.handlers.ts:handleReviewCommand',
    hasModeVariant:true,
    prompt:'Команда !review вручную создаёт задачу ревью для существующего треда. Полезно, когда бот был на паузе или не был настроен на момент исходного сообщения. Она получает корневое сообщение, проверяет regex и назначает ревьюеров.',
    steps:[
      S('check','Проверить наличие активной задачи в треде'),
      S('early-exit','Задача уже существует → ошибка'),
      S('check','Найти конфигурацию канала'),
      S('early-exit','Канал не найден → ошибка "сначала выполните /init"'),
      S('check','Проверить regex на безопасность (ReDoS)'),
      S('early-exit','Regex небезопасен → ошибка'),
      S('slack','Получить корневое сообщение через Slack API (conversations.history)'),
      S('early-exit','Не удалось получить сообщение → ошибка'),
      S('check','Проверить корневое сообщение по regex канала'),
      S('early-exit','Нет совпадения → ошибка'),
      S('service','Получить участников волны 1, исключить автора корневого сообщения, перемешать, применить лимит'),
      S('early-exit','0 подходящих ревьюеров → ошибка'),
      S('db','createTaskWithReviewers — INSERT задачи и ревьюеров в транзакции'),
      S('slack','Ответить в треде с упоминанием ревьюеров'),
      S('slack','Обновить эмодзи счётчика ревьюеров'),
    ],
    gatekeeperSteps:[
      S('check','Проверить наличие активной задачи в треде'),
      S('early-exit','Задача уже существует → ошибка'),
      S('check','Найти конфигурацию канала'),
      S('early-exit','Канал не найден → ошибка'),
      S('check','Проверить regex на безопасность (ReDoS)'),
      S('early-exit','Regex небезопасен → ошибка'),
      S('slack','Получить корневое сообщение через Slack API'),
      S('early-exit','Не удалось получить сообщение → ошибка'),
      S('check','Проверить корневое сообщение по regex канала'),
      S('early-exit','Нет совпадения → ошибка'),
      S('service','Режим гейткипера: назначить только gatekeeper_slack_id'),
      S('db','createTaskWithReviewers в транзакции'),
      S('slack','Ответить в треде с упоминанием гейткипера'),
      S('slack','Обновить эмодзи счётчика ревьюеров'),
    ],
  },

  /* ===== REACTIONS ===== */
  {
    id:'eyes-emoji',category:'Реакции',name:'\ud83d\udc40 Eyes emoji',
    source:'src/slack/handlers/event.handlers.ts:handleReactionAdded',
    hasModeVariant:false,
    prompt:'Когда ревьюер реагирует эмодзи «глаза» на сообщение ревью, его ревью молча откладывается на 2 часа. Сообщения в Slack не отправляются. Отложенность автоматически сбрасывается при запуске крон‑напоминаний.',
    steps:[
      S('filter','Обрабатывать только реакции на сообщения'),
      S('filter','Удалить модификатор оттенка кожи из имени эмодзи'),
      S('check','Проверить, что эмодзи — «глаза»'),
      S('early-exit','Не эмодзи «глаза» → остановка'),
      S('check','Получить активную задачу для этого сообщения'),
      S('early-exit','Нет активной задачи → тихий выход'),
      S('check','Найти ревьюера пользователя в текущей волне'),
      S('early-exit','Не ревьюер → тихий выход'),
      S('db','postponeReviewer — SELECT FOR UPDATE, установить "postponed" до now+2h'),
    ],
  },

  /* ===== SLASH COMMANDS ===== */
  {
    id:'init',category:'Слэш-команды',name:'/init <regex>',
    source:'src/slack/handlers/command.handlers.ts:handleInitCommand',
    hasModeVariant:false,
    prompt:'Команда /init инициализирует бота в канале с regex‑шаблоном для поиска сообщений на ревью. Она проверяет regex на синтаксис и ReDoS, создаёт конфигурацию канала и волну 1, затем открывает Slack‑модалку для настройки участников.',
    steps:[
      S('filter','Подтвердить команду (ack)'),
      S('check','Проверить предоставленный regex'),
      S('early-exit','Нет шаблона → ошибка "укажите regex"'),
      S('check','Проверить синтаксис regex и ReDoS безопасность'),
      S('early-exit','Неверный или небезопасный regex → ошибка'),
      S('db','initializeChannel — INSERT канала с regex'),
      S('check','Проверить, не инициализирован ли канал'),
      S('early-exit','Уже инициализирован → "бот уже был инициализирован"'),
      S('slack','Ответить: "бот инициализирован с шаблоном"'),
      S('db','createWave — INSERT волны 1'),
      S('slack','Открыть модалку настройки волны 1 (views.open)'),
    ],
  },
  {
    id:'cron',category:'Слэш-команды',name:'/cron <expr>',
    source:'src/slack/handlers/command.handlers.ts:handleCronCommand',
    hasModeVariant:false,
    prompt:'Команда /cron обновляет расписание напоминаний для канала. Она валидирует cron-выражение, сохраняет его в базу и обновляет повторяющееся задание BullMQ, чтобы напоминания шли по новому расписанию.',
    steps:[
      S('filter','Подтвердить команду (ack)'),
      S('check','Проверить предоставленное cron-выражение'),
      S('early-exit','Нет выражения → ошибка с примером'),
      S('check','Проверить синтаксис cron через cron-parser'),
      S('early-exit','Неверный cron → ошибка с подсказкой формата'),
      S('db','updateCronExpression \u2014 UPDATE channel.cron_expression'),
      S('queue','Сгенерировать событие CHANNEL_SCHEDULE_UPDATE → upsert повторяющегося задания BullMQ'),
      S('slack','Ответить: "расписание обновлено"'),
    ],
  },
  {
    id:'pause-resume',category:'Слэш-команды',name:'/pause & /resume',
    source:'src/slack/handlers/command.handlers.ts:handlePauseCommand',
    hasModeVariant:false,
    prompt:'Команды /pause и /resume переключают активность бота в канале. Ими могут пользоваться только админы/владельцы рабочей области и создатели канала. На паузе новые сообщения игнорируются, а напоминания пропускают канал.',
    steps:[
      S('filter','Подтвердить команду (ack)'),
      S('check','Проверить админские права (admin/owner/creator)'),
      S('early-exit','Не админ → ошибка прав'),
      S('db','pauseChannel / resumeChannel \u2014 UPDATE channel.is_active'),
      S('slack','Ответить: "бот поставлен на паузу/возобновлён"'),
    ],
  },
  {
    id:'waves',category:'Слэш-команды',name:'/waves [N]',
    source:'src/slack/handlers/command.handlers.ts:handleWavesCommand',
    hasModeVariant:false,
    prompt:'Команда /waves либо выводит список всех волн с участниками (без аргумента), либо открывает модалку настройки конкретной волны. Требуются админские права.',
    steps:[
      S('filter','Подтвердить команду (ack)'),
      S('check','Проверить админские права'),
      S('early-exit','Не админ → ошибка прав'),
      B('Номер волны указан?',
        [
          S('check','Проверить номер волны (целое >0, ≤ max)'),
          S('early-exit','Неверный номер → ошибка'),
          S('db','Получить или создать волну по каналу и номеру'),
          S('service','Получить участников текущей волны'),
          S('slack','Открыть модалку настройки волны (views.open)'),
        ],
        [
          S('db','getWavesWithMembers для канала'),
          S('early-exit','Волны не настроены → "используйте /waves N"'),
          S('service','Сформировать список волн с участниками и max_reviewers'),
          S('service','Проверить активного гейткипера, добавить инфо'),
          S('slack','Ответить ephemeral со списком волн'),
        ]
      ),
    ],
  },
  {
    id:'gatekeeper',category:'Слэш-команды',name:'/gatekeeper',
    source:'src/slack/handlers/command.handlers.ts:handleGatekeeperCommand',
    hasModeVariant:false,
    prompt:'Команда /gatekeeper управляет режимом гейткипера в канале. Без аргументов показывает статус. С @user назначает гейткипера. С "off" отключает режим. Требуются админские права.',
    steps:[
      S('filter','Подтвердить команду (ack)'),
      S('check','Проверить админские права'),
      S('early-exit','Не админ → ошибка прав'),
      B('Указан @user?',
        [
          S('check','Распарсить упоминание @user из аргумента'),
          S('early-exit','Неверный формат упоминания → ошибка'),
          S('db','setGatekeeper — UPDATE channel.gatekeeper_slack_id'),
          S('slack','Ответить: "режим гейткипера включён для @user"'),
        ],
        [
          B('Аргумент — "off"?',
            [
              S('db','setGatekeeper(null) — отключить гейткипера'),
              S('slack','Ответить: "режим гейткипера выключен"'),
            ],
            [
              S('db','getGatekeeper — прочитать текущий статус гейткипера'),
              S('slack','Ответить ephemeral со статусом гейткипера'),
            ]
          ),
        ]
      ),
    ],
  },

  /* ===== MODAL ===== */
  {
    id:'wave-config',category:'Модальное окно',name:'Отправка конфигурации волны',
    source:'src/slack/handlers/view.handlers.ts:handleWaveConfigSubmit',
    hasModeVariant:false,
    prompt:'Когда отправляется модалка настройки волны, бот валидирует ввод, обновляет участников волны и max_reviewers в одной транзакции, при необходимости удаляет хвостовые пустые волны и отправляет ephemeral‑подтверждение.',
    steps:[
      S('filter','Разобрать private_metadata (channelId, waveNumber, waveId)'),
      S('early-exit','Нет метаданных → ack с ошибкой валидации'),
      S('check','Проверить, что пользователь состоит в канале (security check)'),
      S('early-exit','Не участник → ack с ошибкой доступа'),
      S('filter','Извлечь выбранных пользователей и max_reviewers из формы'),
      S('check','Проверить, что max_reviewers — положительное число (если задано)'),
      S('early-exit','Неверное число → ack с ошибкой валидации'),
      S('filter','Подтвердить отправку (ack)'),
      S('db','updateWaveConfiguration — UPDATE волны + DELETE/INSERT участников в транзакции'),
      S('check','Проверить, пуст ли список участников'),
      B('Участники пусты?',
        [
          S('db','deleteTrailingEmptyWaves — удалить волны без последователей'),
          S('slack','Отправить ephemeral: "волна(ы) удалена(ы)"'),
        ],
        [
          S('slack','Отправить ephemeral: "конфигурация волны N сохранена"'),
        ]
      ),
    ],
  },

  /* ===== SCHEDULED ===== */
  {
    id:'cron-reminders',category:'Планировщик',name:'Крон-напоминания',
    source:'src/queue/reminder.processor.ts:process',
    hasModeVariant:false,
    prompt:'Процессор крон‑напоминаний запускается по расписанию для каждого канала. Он проверяет протухшие джобы, активность канала, проходит активные задачи, проверяет статусы Slack у каждого ревьюера (huddle, day off, vacation) и отправляет единое напоминание доступным ревьюерам.',
    steps:[
      S('check','Защита: проверить возраст джобы против порога 30с'),
      S('early-exit','Протухшая джоба (>30с, напр. после рестарта) → пропустить'),
      S('check','Проверить, что канал активен'),
      S('early-exit','Канал неактивен → пропустить'),
      S('service','Получить все активные задачи канала'),
      S('filter','Для каждой задачи: пропустить, если статус "rework"'),
      S('service','Получить ожидающих ревьюеров текущей волны (сбрасывает просроченных отложенных)'),
      B('Найдены ожидающие ревьюеры?',
        [
          S('service','Для каждого ревьюера: проверить статус Slack через getUserInfo'),
          B('У пользователя есть статус‑эмодзи?',
            [
              S('filter','Наушники (huddle) → пропустить этот тик'),
              S('filter','Запрещающий знак (day off) → пропустить этот тик'),
              S('service','Пальма (vacation) → auto-skip навсегда + переход волны'),
            ],
            [
              S('service','Пользователь доступен → собрать для общего напоминания'),
            ]
          ),
          S('slack','Отправить одно общее напоминание в треде, упомянув всех доступных ревьюеров'),
          S('db','Обновить task.last_reminder_at'),
        ],
        [
          S('service','tryAdvanceTask — восстановление застрявшей задачи (переход волны или завершение)'),
          S('slack','Обновить эмодзи счётчика ревьюеров'),
        ]
      ),
    ],
  },

  /* ===== ЛС ===== */
  {
    id:'qa-question',category:'ЛС',name:'Вопрос в QA',
    source:'src/qa/handlers/dm.handler.ts:DmHandler',
    hasModeVariant:false,
    prompt:'Когда пользователь пишет боту в ЛС, это считается вопросом в QA. Бот проверяет лимит (20 в час), отправляет вопрос в QA‑сервис (OpenAI) и отвечает результатом.',
    steps:[
      S('filter','Обрабатывать только ЛС (channel_type = "im")'),
      S('filter','Игнорировать сообщения ботов и подтипы'),
      S('check','Проверить лимит (20 запросов/час на пользователя)'),
      S('early-exit','Лимит превышен → ответить временем повтора'),
      S('service','qaService.answerQuestion — отправить в OpenAI'),
      S('slack','Ответить результатом'),
    ],
  },
];

/* ========== STATE ========== */
let selectedEventId = null;
let gatekeeperMode = false;
let highlightType = null;
let focusedIndex = 0;
let stepCounter = 0;

/* ========== DOM REFS ========== */
const eventListEl = document.getElementById('eventList');
const searchInput = document.getElementById('searchInput');
const modeToggle = document.getElementById('modeToggle');
const flowArea = document.getElementById('flowArea');
const emptyState = document.getElementById('emptyState');
const legendEl = document.getElementById('legend');
const promptText = document.getElementById('promptText');
const copyBtn = document.getElementById('copyBtn');
const menuToggle = document.getElementById('menuToggle');
const sidebar = document.getElementById('sidebar');
const sidebarOverlay = document.getElementById('sidebarOverlay');

/* ========== RENDER SIDEBAR ========== */
function renderEventList(){
  eventListEl.textContent = '';
  let currentCat = null;
  EVENTS.forEach(function(ev,i){
    if(ev.category !== currentCat){
      currentCat = ev.category;
      var cat = document.createElement('div');
      cat.className = 'category-label';
      cat.textContent = currentCat;
      cat.setAttribute('role','presentation');
      eventListEl.appendChild(cat);
    }
    var item = document.createElement('div');
    item.className = 'event-item';
    item.setAttribute('role','option');
    item.setAttribute('data-event-id',ev.id);
    item.setAttribute('data-index',String(i));
    item.tabIndex = -1;

    var dot = document.createElement('span');
    dot.className = 'event-dot';
    item.appendChild(dot);

    var nameEl = document.createElement('span');
    nameEl.className = 'event-name';
    nameEl.textContent = ev.name;
    item.appendChild(nameEl);

    item.addEventListener('click',function(){
      selectEvent(ev.id);
      closeMobileSidebar();
    });
    eventListEl.appendChild(item);
  });
}

function getVisibleItems(){
  return Array.from(eventListEl.querySelectorAll('.event-item:not(.hidden)'));
}

function updateActiveItem(){
  eventListEl.querySelectorAll('.event-item').forEach(function(el){
    el.classList.toggle('active',el.getAttribute('data-event-id')===selectedEventId);
  });
}

/* ========== SEARCH ========== */
searchInput.addEventListener('input',function(){
  var q = searchInput.value.toLowerCase().trim();
  var items = eventListEl.querySelectorAll('.event-item');
  var cats = eventListEl.querySelectorAll('.category-label');
  var catVisible = {};

  items.forEach(function(item){
    var ev = EVENTS[parseInt(item.getAttribute('data-index'))];
    var match = !q || ev.name.toLowerCase().indexOf(q) !== -1 || ev.category.toLowerCase().indexOf(q) !== -1;
    item.classList.toggle('hidden',!match);
    if(match) catVisible[ev.category] = true;
  });

  cats.forEach(function(cat){
    cat.style.display = catVisible[cat.textContent] ? '' : 'none';
  });

  var visible = getVisibleItems();
  if(visible.length > 0 && selectedEventId){
    var sel = eventListEl.querySelector('[data-event-id="'+selectedEventId+'"]');
    if(sel && sel.classList.contains('hidden')){
      selectEvent(visible[0].getAttribute('data-event-id'));
    }
  }
});

/* ========== KEYBOARD NAV ========== */
eventListEl.addEventListener('keydown',function(e){
  var visible = getVisibleItems();
  if(visible.length === 0) return;

  var current = visible.findIndex(function(el){return el.getAttribute('data-event-id')===selectedEventId});
  if(current === -1) current = 0;

  if(e.key === 'ArrowDown'){
    e.preventDefault();
    current = Math.min(current+1, visible.length-1);
    selectEvent(visible[current].getAttribute('data-event-id'));
    visible[current].scrollIntoView({block:'nearest'});
  } else if(e.key === 'ArrowUp'){
    e.preventDefault();
    current = Math.max(current-1, 0);
    selectEvent(visible[current].getAttribute('data-event-id'));
    visible[current].scrollIntoView({block:'nearest'});
  } else if(e.key === 'Enter'){
    e.preventDefault();
    selectEvent(visible[current].getAttribute('data-event-id'));
  }
});

/* ========== LEGEND ========== */
function renderLegend(){
  legendEl.textContent = '';
  STEP_TYPES.forEach(function(st){
    var chip = document.createElement('span');
    chip.className = 'legend-chip '+st.key;
    chip.textContent = st.label;
    chip.setAttribute('role','button');
    chip.setAttribute('tabindex','0');
    chip.addEventListener('click',function(){toggleHighlight(st.key)});
    chip.addEventListener('keydown',function(e){if(e.key==='Enter')toggleHighlight(st.key)});
    legendEl.appendChild(chip);
  });
}

function toggleHighlight(type){
  if(highlightType === type){
    highlightType = null;
    flowArea.className = 'flow-area';
  } else {
    highlightType = type;
    flowArea.className = 'flow-area highlight-'+type;
  }
  legendEl.querySelectorAll('.legend-chip').forEach(function(chip){
    var t = null;
    STEP_TYPES.forEach(function(st){if(chip.classList.contains(st.key))t=st.key});
    chip.classList.toggle('active',t===highlightType);
  });
}

/* ========== SELECT EVENT ========== */
function selectEvent(id){
  selectedEventId = id;
  var ev = EVENTS.find(function(e){return e.id===id});
  if(!ev) return;

  updateActiveItem();

  modeToggle.disabled = !ev.hasModeVariant;
  if(!ev.hasModeVariant){
    modeToggle.checked = false;
    gatekeeperMode = false;
  }

  renderFlow();
  updateHash();
}

/* ========== MODE TOGGLE ========== */
modeToggle.addEventListener('change',function(){
  gatekeeperMode = modeToggle.checked;
  renderFlow();
  updateHash();
});

/* ========== RENDER FLOW ========== */
function renderFlow(){
  var ev = EVENTS.find(function(e){return e.id===selectedEventId});
  if(!ev){
    emptyState.style.display = 'flex';
    flowArea.querySelectorAll('.flow-title,.flow-source,.flow-container').forEach(function(el){el.remove()});
    return;
  }
  emptyState.style.display = 'none';

  // Clear previous
  flowArea.querySelectorAll('.flow-title,.flow-source,.flow-container').forEach(function(el){el.remove()});

  var title = document.createElement('div');
  title.className = 'flow-title';
  title.textContent = ev.name;
  flowArea.insertBefore(title, emptyState);

  var source = document.createElement('div');
  source.className = 'flow-source';
  source.textContent = ev.source;
  flowArea.insertBefore(source, emptyState);

  var steps = gatekeeperMode && ev.gatekeeperSteps ? ev.gatekeeperSteps : ev.steps;

  var container = document.createElement('div');
  container.className = 'flow-container';
  flowArea.insertBefore(container, emptyState);

  stepCounter = 0;
  var delay = 0;
  renderSteps(steps, container, 24, delay);

  promptText.textContent = ev.prompt;

  // reset highlight
  highlightType = null;
  flowArea.className = 'flow-area';
  legendEl.querySelectorAll('.legend-chip').forEach(function(c){c.classList.remove('active')});

  flowArea.scrollTop = 0;
}

function renderSteps(steps, parent, marginLeft, baseDelay){
  var delay = baseDelay;
  steps.forEach(function(step){
    if(step.type === 'branch'){
      delay = renderВетвление(step, parent, marginLeft, delay);
    } else {
      stepCounter++;
      // Arrow
      var arrow = document.createElement('div');
      arrow.className = 'arrow-connector';
      arrow.style.marginLeft = marginLeft+'px';
      parent.appendChild(arrow);

      // Step
      var wrapper = document.createElement('div');
      wrapper.className = 'step-wrapper';
      wrapper.style.marginLeft = marginLeft+'px';

      var card = document.createElement('div');
      card.className = 'step-card '+step.type;

      var label = document.createElement('div');
      label.className = 'step-label';
      label.textContent = getTypeLabel(step.type);
      card.appendChild(label);

      var text = document.createElement('div');
      text.className = 'step-text';
      text.textContent = step.text;
      card.appendChild(text);

      // Step number badge
      var numBadge = document.createElement('div');
      numBadge.className = 'step-number';
      numBadge.textContent = String(stepCounter).padStart(2,'0');
      card.appendChild(numBadge);

      if(step.type === 'early-exit'){
        var footer = document.createElement('div');
        footer.className = 'exit-footer';
        footer.textContent = 'Поток завершён';
        card.appendChild(footer);
      }

      wrapper.appendChild(card);
      parent.appendChild(wrapper);

      scheduleReveal(wrapper, delay);
      delay += 80;
    }
  });
  return delay;
}

function renderВетвление(step, parent, marginLeft, baseDelay){
  var delay = baseDelay;

  // Arrow into branch
  var arrow = document.createElement('div');
  arrow.className = 'arrow-connector';
  arrow.style.marginLeft = marginLeft+'px';
  parent.appendChild(arrow);

  // Ветвление card
  var bWrapper = document.createElement('div');
  bWrapper.className = 'step-wrapper';
  bWrapper.style.marginLeft = marginLeft+'px';

  var bCard = document.createElement('div');
  bCard.className = 'step-card branch';

  var bLabel = document.createElement('div');
  bLabel.className = 'step-label';
  bLabel.textContent = getTypeLabel('branch');
  bCard.appendChild(bLabel);

  var bText = document.createElement('div');
  bText.className = 'step-text';
  bText.textContent = step.text;
  bCard.appendChild(bText);

  bWrapper.appendChild(bCard);
  parent.appendChild(bWrapper);
  scheduleReveal(bWrapper, delay);
  delay += 80;

  // Paths container
  var pathsEl = document.createElement('div');
  pathsEl.className = 'branch-paths';
  pathsEl.style.marginLeft = marginLeft+'px';
  parent.appendChild(pathsEl);

  // Yes path
  if(step.yes && step.yes.length > 0){
    var yesPath = document.createElement('div');
    yesPath.className = 'branch-path';
    var yesLabel = document.createElement('div');
    yesLabel.className = 'branch-path-label yes';
    yesLabel.textContent = '\u2713 Yes';
    yesPath.appendChild(yesLabel);
    pathsEl.appendChild(yesPath);
    delay = renderSteps(step.yes, yesPath, 8, delay);
  }

  // No path
  if(step.no && step.no.length > 0){
    var noPath = document.createElement('div');
    noPath.className = 'branch-path';
    var noLabel = document.createElement('div');
    noLabel.className = 'branch-path-label no';
    noLabel.textContent = '\u2717 No';
    noPath.appendChild(noLabel);
    pathsEl.appendChild(noPath);
    delay = renderSteps(step.no, noPath, 8, delay);
  } else {
    var noPath = document.createElement('div');
    noPath.className = 'branch-path';
    var noLabel = document.createElement('div');
    noLabel.className = 'branch-path-label no';
    noLabel.style.opacity = '.5';
    noLabel.textContent = '\u2717 No \u2192 (continues)';
    noPath.appendChild(noLabel);
    pathsEl.appendChild(noPath);
  }

  return delay;
}

function scheduleReveal(el, delay){
  setTimeout(function(){el.classList.add('visible')}, delay);
}

/* ========== URL HASH ========== */
function updateHash(){
  var parts = [];
  if(selectedEventId) parts.push('event='+encodeURIComponent(selectedEventId));
  if(gatekeeperMode) parts.push('mode=gatekeeper');
  var hash = parts.length > 0 ? '#'+parts.join('&') : '';
  history.replaceState(null,'',location.pathname+location.search+hash);
}

function readHash(){
  var hash = location.hash.replace(/^#/,'');
  if(!hash) return;
  var params = {};
  hash.split('&').forEach(function(pair){
    var kv = pair.split('=');
    if(kv.length===2) params[decodeURIComponent(kv[0])] = decodeURIComponent(kv[1]);
  });
  if(params.event){
    var ev = EVENTS.find(function(e){return e.id===params.event});
    if(ev){
      if(params.mode === 'gatekeeper' && ev.hasModeVariant){
        gatekeeperMode = true;
        modeToggle.checked = true;
      }
      selectEvent(params.event);
      return;
    }
  }
}

/* ========== COPY ========== */
copyBtn.addEventListener('click',function(){
  var ev = EVENTS.find(function(e){return e.id===selectedEventId});
  if(!ev) return;
  var text = ev.name + ' \u2014 ' + ev.prompt;
  if(navigator.clipboard && navigator.clipboard.writeText){
    navigator.clipboard.writeText(text).then(showCopied).catch(fallbackКопировать.bind(null,text));
  } else {
    fallbackКопировать(text);
  }
});

function fallbackКопировать(text){
  var ta = document.createElement('textarea');
  ta.value = text;
  ta.style.position = 'исправлено';
  ta.style.left = '-9999px';
  document.body.appendChild(ta);
  ta.select();
  try{document.execCommand('copy');showCopied()}catch(e){}
  document.body.removeChild(ta);
}

function showCopied(){
  copyBtn.textContent = 'Скопировано!';
  copyBtn.classList.add('copied');
  setTimeout(function(){
    copyBtn.textContent = 'Копировать';
    copyBtn.classList.remove('copied');
  },1500);
}

/* ========== MOBILE MENU ========== */
function closeMobileSidebar(){
  sidebar.classList.remove('open');
  sidebarOverlay.classList.remove('visible');
}

menuToggle.addEventListener('click',function(){
  var isOpen = sidebar.classList.toggle('open');
  sidebarOverlay.classList.toggle('visible',isOpen);
});

sidebarOverlay.addEventListener('click',closeMobileSidebar);

/* ========== INIT ========== */
renderEventList();
renderLegend();
readHash();
if(!selectedEventId){
  selectEvent(EVENTS[0].id);
}

})();
</script>
</body>
</html>
